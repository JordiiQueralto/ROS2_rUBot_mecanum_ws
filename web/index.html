<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>ROS Web Dashboard</title>
  <script src="https://cdn.jsdelivr.net/npm/roslib@1/build/roslib.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/nipplejs/0.9.0/nipplejs.min.js"></script>
  <style>
    :root{
      --gap: 20px;
      --card-bg: #fff;
      --card-bd: #ccc;
      --page-bg: #414141;
    }

    body {
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 20px;
      background-color: var(--page-bg);
      color: #e6e6e6;
    }

    .connection-form {
      width: 100%;
      margin-bottom: var(--gap);
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      align-items: center;
    }
    .connection-form label { color: #fff; }
    .connection-form input[type="number"]{
      width: 70px;
      padding: 6px 8px;
      border-radius: 6px;
      border: 1px solid #bbb;
      background: #fff;
    }
    .connection-form button{
      padding: 8px 14px;
      border-radius: 6px;
      border: 1px solid #bbb;
      background: #f5f5f5;
      cursor: pointer;
    }
    .connection-form button:hover { filter: brightness(0.97); }
    .connection-form button.connected {
      background: #2ecc71;
      border-color: #2ecc71;
      color: #fff;
    }

    .dashboard {
      display: grid;
      grid-template-columns: 1fr 1fr;
      grid-template-areas:
        "camera right"
        "map    pos";
      align-items: center;
      justify-items: center;
      gap: var(--gap);
    }

    #camera-feed      { grid-area: camera; }
    .right-panel      { grid-area: right; }
    .map-display      { grid-area: map; }
    .position-display { grid-area: pos; }

    .right-panel {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 8px;
    }

    .joy-legend {
      font-size: 1rem;
      font-weight: 700;
      color: #eee;
      text-align: center;
      margin-top: 0;
    }

    .joystick-container {
      width: 200px;
      height: 200px;
      background-color: #ddd;
      border-radius: 50%;
      position: relative;
      overflow: hidden;
      touch-action: none;
    }

    .joy-vel {
      font-size: 0.9rem;
      color: #ddd;
      text-align: center;
    }

    /* Slider ω sota vels, més gruixut */
    .omega-wrap {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      color: #eee;
      font-size: 0.95rem;
      width: 100%;
      margin-top: 4px;
    }

    #omegaSlider {
      -webkit-appearance: none;
      appearance: none;
      width: 160px;
      height: 10px;
      border-radius: 6px;
      background: #666;
      outline: none;
    }
    #omegaSlider::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: #f5f5f5;
      border: 2px solid #222;
      cursor: pointer;
    }
    #omegaSlider::-moz-range-thumb {
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: #f5f5f5;
      border: 2px solid #222;
      cursor: pointer;
    }

    .map-display { width: min(280px, 100%); }

    .image-view {
      width: 360px;
      height: 270px;
      background-color: #000;
      border-radius: 5px;
      border: 1px solid var(--card-bd);
      object-fit: cover;
      display: block;
    }

    .map-image {
      width: 100%;
      height: auto;
      border: 1px solid var(--card-bd);
      border-radius: 5px;
      display: block;
      background-color: #e6e6e6;
    }

    @media (max-width: 900px) {
      .dashboard {
        grid-template-columns: 1fr;
        grid-template-areas:
          "camera"
          "right"
          "map"
          "pos";
        justify-items: center;
      }

      .joystick-container {
        width: 160px;
        height: 160px;
      }

      .image-view {
        width: 100%;
        max-width: 520px;
        height: auto;
      }

      .position-display,
      .map-display {
        width: 100%;
        max-width: 520px;
      }
    }
  </style>
</head>

<body>
  <div class="connection-form">
    <label for="robotNumber">Robot:</label>
    <input id="robotNumber" type="number" min="1" max="9" value="1" title="Robot number"/>
    <button id="connectBtn" onclick="connectToROS()">Connect</button>
  </div>

  <div class="dashboard">
    <!-- Camera -->
    <img class="image-view" id="camera-feed" alt="Camera Feed" />

    <!-- Right panel -->
    <aside class="right-panel">
      <div class="joy-legend">Joystick</div>
      <div class="joystick-container" id="joystick_h"></div>

      <div class="joy-vel">
        vₓ: <span id="vx">0.00</span> m/s · vᵧ: <span id="vy">0.00</span> m/s
      </div>

      <!-- Slider ω sota vels: esquerra = ω>0, dreta = ω<0 -->
      <div class="omega-wrap">
        <label for="omegaSlider">ω:</label>
        <input id="omegaSlider" type="range" min="-1" max="1" step="0.01" value="0" />
        <span id="omegaVal">0.00</span> rad/s
      </div>
    </aside>

    <!-- Map + LiDAR -->
    <div class="map-display">
      <h3>Map + LiDAR</h3>
      <canvas id="map-canvas" class="map-image" width="200" height="200"></canvas>
    </div>

    <!-- Pose -->
    <div class="position-display">
      <h3>Position & Orientation</h3>
      <p>X (m): <span id="position-x">0</span></p>
      <p>Y (m): <span id="position-y">0</span></p>
      <p>&Theta; (º): <span id="rotation-z">0</span></p>
    </div>
  </div>

  <script>
    let ros;
    let cmdVelTopic;

    // ===== Config =====
    const MAP_RESOLUTION = 0.01;      // m/px
    const ROBOT_RADIUS   = 5;         // px
    const SPEED_VECTOR_SCALE = 1.0;   // m per (m/s) per la fletxa (senzill)
    const maxSpeed = 0.3;             // m/s
    const maxTurn  = 0.4;             // rad/s
    const distanceFactor = 75;        // joystick

    // ===== State =====
    let currentLinearX = 0;
    let currentLinearY = 0;
    let currentAngularZ = 0;

    let mapImage = new Image();
    let latestScan = null;

    // Pose centrada i orientació relativa
    let lastRobotX = 0;      // en metres, frame display X (forward inicial)
    let lastRobotY = 0;      // en metres, frame display Y (dreta/esquerra segons conversió)
    let lastRobotYaw = 0;    // yaw relatiu (0 = forward inicial)

    let odomCenterSet = false;
    let odomCenterX = 0;
    let odomCenterY = 0;

    let yawOffsetSet = false;
    let yawOffset = 0;

    function getRosbridgeAddress() {
      const currentUrl = window.location.href;
      const rosbridgeUrl = currentUrl.replace(/\/webpage\/?$/, '/rosbridge/');
      return rosbridgeUrl.replace(/^http/, 'ws').replace(/^https/, 'wss');
    }

    function connectToROS() {
      if (ros && ros.isConnected) {
        console.log('Ja estàs connectat.');
        return;
      }

      document.getElementById('connectBtn')?.setAttribute('disabled', 'disabled');
      const robotNum = parseInt(document.getElementById('robotNumber').value) || 1;

      const mapName = "map";
      const mapPath = `maps/${mapName}.png`;

      const host = window.location.hostname;
      const scheme = location.protocol === 'https:' ? 'wss' : 'ws';

      let rosbridgeAddress;
      if (host.startsWith("192.168.1.")) {
        const lastOctet = robotNum * 10 + 4;
        const robotHost = `192.168.1.${lastOctet}`;
        rosbridgeAddress = `${scheme}://${robotHost}:9090`;
      } else {
        rosbridgeAddress = getRosbridgeAddress();
      }
      console.log("Connecting to:", rosbridgeAddress);

      resizeMapCanvas();
      mapImage.onload = () => {
        resizeMapCanvas();
      };
      mapImage.src = mapPath;

      ros = new ROSLIB.Ros({ url: rosbridgeAddress });

      const connectBtn = document.getElementById('connectBtn');
      ros.on('connection', function () {
        console.log('Connected to rosbridge:', rosbridgeAddress);
        if (connectBtn) connectBtn.classList.add('connected');
        setupTopics();
        setupControls();
        document.getElementById('connectBtn')?.removeAttribute('disabled');
        ros.isConnected = true;
      });

      ros.on('error', function (error) {
        console.error('Connection Error:', error);
        if (connectBtn) connectBtn.classList.remove('connected');
        document.getElementById('connectBtn')?.removeAttribute('disabled');
        ros.isConnected = false;
      });

      ros.on('close', function () {
        console.log('Connection closed.');
        if (connectBtn) connectBtn.classList.remove('connected');
        document.getElementById('connectBtn')?.removeAttribute('disabled');
        ros.isConnected = false;
      });
    }

    function quaternionToYaw(q) {
      const siny_cosp = 2 * (q.w * q.z + q.x * q.y);
      const cosy_cosp = 1 - 2 * (q.y * q.y + q.z * q.z);
      return Math.atan2(siny_cosp, cosy_cosp);
    }

    function setupTopics() {
      // cmd_vel
      cmdVelTopic = new ROSLIB.Topic({
        ros: ros,
        name: '/cmd_vel',
        messageType: 'geometry_msgs/msg/Twist'
      });

      // Camera
      const imageTopic = new ROSLIB.Topic({
        ros: ros,
        name: '/image_raw/compressed',
        messageType: 'sensor_msgs/msg/CompressedImage'
      });
      imageTopic.subscribe((message) => {
        document.getElementById('camera-feed').src =
          "data:image/jpeg;base64," + message.data;
      });

      // Odometry
      const odomTopic = new ROSLIB.Topic({
        ros: ros,
        name: '/odom',
        messageType: 'nav_msgs/msg/Odometry'
      });
      odomTopic.subscribe((message) => {
        const position = message.pose.pose.position;
        const orientation = message.pose.pose.orientation;
        const twist = message.twist.twist;

        const yawAbs = quaternionToYaw(orientation);

        // Centrat a primer odom
        if (!odomCenterSet) {
          odomCenterX = position.x;
          odomCenterY = position.y;
          odomCenterSet = true;
        }

        // Orientació inicial com a referència (forward inicial = +X display)
        if (!yawOffsetSet) {
          yawOffset = yawAbs;
          yawOffsetSet = true;
        }

        const yawRel = yawAbs - yawOffset;
        lastRobotYaw = yawRel;

        // Frame display:
        // +X_display = endavant inicial
        // +Y_display = dreta inicial
        // A partir de les coords odom (x,y), definim:
        const dx = position.x - odomCenterX;   // X odom (forward)
        const dy = position.y - odomCenterY;   // Y odom (left)

        // Projectem al frame inicial:
        // Com volem només centrat (no rotar mapa global), usem directament:
        lastRobotX = dx;       // endavant (+X)
        lastRobotY = -dy;      // dreta = -left

        document.getElementById('position-x').textContent = lastRobotX.toFixed(2);
        document.getElementById('position-y').textContent = lastRobotY.toFixed(2);
        document.getElementById('rotation-z').textContent =
          (lastRobotYaw * 180 / Math.PI).toFixed(1);

        // Velocitat en base_link (x forward, y left)
        const vx_body = twist.linear.x;
        const vy_body = twist.linear.y;

        // A món relatiu (usant yawRel)
        const cosY = Math.cos(yawRel);
        const sinY = Math.sin(yawRel);
        const vx_world = vx_body * cosY - vy_body * sinY;
        const vy_world_left = vx_body * sinY + vy_body * cosY;
        const vy_world = -vy_world_left; // dreta positiva

        drawRobotState(lastRobotX, lastRobotY,
                       vx_world, vy_world,
                       lastRobotYaw, latestScan);
      });

      // LiDAR /scan
      const scanTopic = new ROSLIB.Topic({
        ros: ros,
        name: '/scan',
        messageType: 'sensor_msgs/msg/LaserScan'
      });
      scanTopic.subscribe((message) => {
        latestScan = message;
      });
    }

    function resizeMapCanvas() {
      const canvas = document.getElementById('map-canvas');
      if (!canvas) return;

      const dpr = window.devicePixelRatio || 1;
      const cssW = canvas.clientWidth || canvas.width;
      const cssH = canvas.clientHeight || canvas.height;

      canvas.width  = Math.round(cssW * dpr);
      canvas.height = Math.round(cssH * dpr);

      const ctx = canvas.getContext('2d');
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }

    // Frame display: +X amunt, +Y dreta
    function worldToPixel(x, y, W, H) {
      const px = W / 2 + (y / MAP_RESOLUTION);
      const py = H / 2 - (x / MAP_RESOLUTION);
      return [px, py];
    }

    // Eixos al centre, ticks 0.30 m
    function drawAxes(ctx, W, H) {
      const cx = W / 2;
      const cy = H / 2;
      const metersPerTick = 0.30;
      const pxPerMeter = 1.0 / MAP_RESOLUTION;
      const tickPx = metersPerTick * pxPerMeter;
      const tickLen = 5;

      ctx.save();

      // Eix X (vermell, vertical)
      ctx.strokeStyle = 'red';
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.moveTo(cx, 0);
      ctx.lineTo(cx, H);
      ctx.stroke();

      // Tics X
      const maxXTicks = Math.floor((H / 2) / tickPx);
      for (let i = 1; i <= maxXTicks; i++) {
        const yUp = cy - i * tickPx;
        const yDn = cy + i * tickPx;

        ctx.beginPath();
        ctx.moveTo(cx - tickLen, yUp);
        ctx.lineTo(cx + tickLen, yUp);
        ctx.stroke();

        ctx.beginPath();
        ctx.moveTo(cx - tickLen, yDn);
        ctx.lineTo(cx + tickLen, yDn);
        ctx.stroke();
      }

      // Eix Y (verd, horitzontal)
      ctx.strokeStyle = 'green';
      ctx.beginPath();
      ctx.moveTo(0, cy);
      ctx.lineTo(W, cy);
      ctx.stroke();

      // Tics Y
      const maxYTicks = Math.floor((W / 2) / tickPx);
      for (let i = 1; i <= maxYTicks; i++) {
        const xR = cx + i * tickPx;
        const xL = cx - i * tickPx;

        ctx.beginPath();
        ctx.moveTo(xR, cy - tickLen);
        ctx.lineTo(xR, cy + tickLen);
        ctx.stroke();

        ctx.beginPath();
        ctx.moveTo(xL, cy - tickLen);
        ctx.lineTo(xL, cy + tickLen);
        ctx.stroke();
      }

      ctx.restore();
    }

    // Dibuix complet
    function drawRobotState(robotX, robotY, velX, velY, yawRel, scanMsg) {
      const canvas = document.getElementById('map-canvas');
      const ctx = canvas.getContext('2d');

      const W = canvas.clientWidth || canvas.width;
      const H = canvas.clientHeight || canvas.height;

      ctx.clearRect(0, 0, W, H);

      if (mapImage.complete && mapImage.naturalWidth > 0) {
        ctx.drawImage(mapImage, 0, 0, W, H);
      }

      drawAxes(ctx, W, H);

      // --- LiDAR ---
      if (scanMsg) {
        const angleMin = scanMsg.angle_min;
        const angleInc = scanMsg.angle_increment;
        const rangeMin = scanMsg.range_min;
        const rangeMax = scanMsg.range_max;
        const ranges = scanMsg.ranges || [];

        ctx.save();
        ctx.fillStyle = 'rgba(255, 215, 0, 0.9)';

        for (let i = 0; i < ranges.length; i++) {
          const r = ranges[i];
          if (!isFinite(r) || r < rangeMin || r > rangeMax) continue;

          const angle = angleMin + i * angleInc;
          const globalAngle = yawRel + angle;

          const wx = robotX + r * Math.cos(globalAngle);
          const wy = robotY + r * Math.sin(globalAngle);

          const [px, py] = worldToPixel(wx, wy, W, H);
          if (px >= 0 && px <= W && py >= 0 && py <= H) {
            ctx.fillRect(px, py, 2, 2);
          }
        }

        ctx.restore();
      }

      // --- Robot cercle ---
      const [robotPx, robotPy] = worldToPixel(robotX, robotY, W, H);
      ctx.beginPath();
      ctx.arc(robotPx, robotPy, ROBOT_RADIUS, 0, Math.PI * 2);
      ctx.fillStyle = 'green';
      ctx.fill();
      ctx.strokeStyle = 'black';
      ctx.stroke();

      // --- Fletxa orientació (blava) ---
      const arrowLen = 0.15; // m
      const tipX = robotX + arrowLen * Math.cos(yawRel);
      const tipY = robotY + arrowLen * Math.sin(yawRel);
      const [ax, ay] = worldToPixel(tipX, tipY, W, H);

      ctx.beginPath();
      ctx.moveTo(robotPx, robotPy);
      ctx.lineTo(ax, ay);
      ctx.lineWidth = 2;
      ctx.strokeStyle = 'blue';
      ctx.stroke();

      // --- Vector velocitat (vermell) ---
      const speed = Math.hypot(velX, velY);
      if (speed > 0.01) {
        const len_m = speed * SPEED_VECTOR_SCALE;
        const vx = robotX + len_m * (velX / speed);
        const vy = robotY + len_m * (velY / speed);
        const [vxPx, vyPx] = worldToPixel(vx, vy, W, H);

        ctx.beginPath();
        ctx.moveTo(robotPx, robotPy);
        ctx.lineTo(vxPx, vyPx);
        ctx.lineWidth = 2;
        ctx.strokeStyle = 'red';
        ctx.stroke();

        // capçal de fletxa alineat
        const ang = Math.atan2(vyPx - robotPy, vxPx - robotPx);
        ctx.save();
        ctx.translate(vxPx, vyPx);
        ctx.rotate(ang);
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(-8, 4);
        ctx.lineTo(-8, -4);
        ctx.closePath();
        ctx.fillStyle = 'red';
        ctx.fill();
        ctx.restore();
      }
    }

    function publishTwist() {
      const mag = Math.hypot(currentLinearX, currentLinearY);
      let vx = currentLinearX;
      let vy = currentLinearY;
      if (mag > maxSpeed && mag > 0) {
        const s = maxSpeed / mag;
        vx *= s;
        vy *= s;
      }

      const twist = new ROSLIB.Message({
        linear:  { x: vx, y: vy, z: 0 },
        angular: { x: 0, y: 0, z: currentAngularZ }
      });

      if (cmdVelTopic) cmdVelTopic.publish(twist);
    }

    function setupControls() {
      const j = nipplejs.create({
        zone: document.getElementById('joystick_h'),
        mode: 'static',
        position: { left: '50%', top: '50%' },
        color: 'red',
        size: 150
      });

      const vxSpan = document.getElementById('vx');
      const vySpan = document.getElementById('vy');
      const omegaSlider = document.getElementById('omegaSlider');
      const omegaVal = document.getElementById('omegaVal');

      j.on('move', (evt, data) => {
        const ratio = Math.min(data.distance / distanceFactor, 1.0);
        const a = data.angle.radian;
        // Amunt: +vx, Dreta: vy negatiu, Esquerra: vy positiu
        currentLinearX = Math.sin(a) * maxSpeed * ratio;
        currentLinearY = -Math.cos(a) * maxSpeed * ratio;
        vxSpan.textContent = currentLinearX.toFixed(2);
        vySpan.textContent = currentLinearY.toFixed(2);
      });

      j.on('end', () => {
        currentLinearX = 0;
        currentLinearY = 0;
        vxSpan.textContent = '0.00';
        vySpan.textContent = '0.00';
      });

      // ω: esquerra (+), dreta (-)
      omegaSlider.addEventListener('input', () => {
        const v = parseFloat(omegaSlider.value) || 0;
        currentAngularZ = -v * maxTurn;
        omegaVal.textContent = currentAngularZ.toFixed(2);
      });

      setInterval(() => {
        publishTwist();
        omegaVal.textContent = currentAngularZ.toFixed(2);
      }, 50);
    }

    window.addEventListener('resize', resizeMapCanvas);
    window.addEventListener('DOMContentLoaded', () => {
      resizeMapCanvas();
      const robotInput = document.getElementById('robotNumber');
      robotInput.addEventListener('change', (e) => {
        let v = parseInt(e.target.value);
        if (v < 1) v = 1;
        if (v > 9) v = 9;
        e.target.value = v;
      });
    });
  </script>
</body>
</html>
